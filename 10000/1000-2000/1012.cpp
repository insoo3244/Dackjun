// https://www.acmicpc.net/problem/1012
// 2026-01-10

// 풀이
/*
배추흰지렁이는 한 연결 요소 당 한 마리면 충분하다

문제는 한 연결 요소를 어떻게 구하냐는 것.

-> 
배추의 위치정보는 xy좌표로 주어짐
2차원 int 배열(이하 '밭')에 배추 위치정보 저장 -> 배추 1 / 없으면 0

(0 0) 부터 탐색 시작
1. 밭의 해당 좌표가 1인 경우 DFS 시작
    -> 밭의 해당 좌표가 0인 경우 탈출
    -> 해당 좌표가 밭의 범위를 넘어갔 경우 탈출
    -> 해당 좌표에 이미 방문한 적이 있을 경우 탈출

2. 밭의 x축 부터 탐색
    2-1. 해당좌표의 x+-1 좌표를 검사
    2-2. 1번의 조건에 따라 탈출할 때 까지 탐색
    2-3. 탐색 종료 후 해당 좌표 y축 탐색

3. 밭의 y축 탐색 
    -> 2번의 과정과 마찬가지로 진행
    -> 탐색 종료 후 cnt++

4. count 출력 준비
    -> 함수가 종료될 때 cnt가 나타내는 정보는 '연결 요소 내 배추의 개수' 임.
    -> main의 반복문 내에서 cnt /= cnt 를 통해, 
        '배추흰지렁이 1마리' 의 의미로 치환.
        -> 반복문이 끝날 때 마다 cnt 초기화 ! ! !
    -> count는 함수가 종료될 때 마다 나오는 cnt /= cnt 의 총합을 모두 더한,
        배추흰지렁이의 총 마릿수가 되는 것임.
    -> count 출력 후, 다음 테스트 케이스를 위해 초기화.
    
==== 오답노트 ====
1. find 함수의 x,y 값 범위 체크를 방문,밭 체크보다 우선에 두어야함.
    -> x,y 범위가 벗어난 상태로 방문,밭 체크를 하게 되면
        배열의 잘못된 범위에 접근하기 때문에 오류가 발생하니, 먼저 처리하기
2. find 함수의 x,y 값 범위 체크 상한선은 상수가 아니어야 함.
    -> 원문 : if(x < 0 || x > 50) { ... }
    x 값이 내가 설정한 밭의 범위를 넘어감에도 불구하고 50을 넘지 않았기 때문에,
    해당 조건문을 통과해버리는 대참사 발생 -> 밭의 크기를 함수인자에 같이 넘겨줌
3. 테스트 케이스 고려해서 배열 초기화 해주기.
    -> count, cnt 잘 초기화 해줬지만 배열을 초기화하는 것을
        아예 인지조차 못하고 있었음.. 초기화 해줄 것

*/

#include <iostream>
#include <vector>

using namespace std;

int farm[50][50]; // 배추 위치정보
int vis[50][50]; // 방문 체크
int cnt = 0; // 배추흰지렁이 마릿수

void find(int x, int y, int m, int n){
    if(x < 0 || x > m) return; // x 범위 체크
    if(y < 0 || y > n) return; // y 범위 체크
    if(vis[y][x] == 1) return; // 방문 체크
    if(farm[y][x] == 0) return; // 밭 체크

    vis[y][x] = 1; // 방문 확인

    // 양 옆으로 탐색
    find(x - 1, y, m, n);
    find(x + 1, y, m, n);

    // 위아래로 탐색
    find(x, y - 1, m, n);
    find(x, y + 1, m, n);
    cnt++;
}


int main(){
    int test; // 테스트 개수
    cin >> test;

    for(int i = 0; i < test; i++){ // 테스트 반복 시작
        // 밭 가로, 세로 길이, 배추 개수 입력
        int m, n, k;
        cin >> m >> n >> k;

        // 배추 위치정보 입력 및 저장
        for(int j = 0; j < k; j++){ 
            int x, y; 
            cin >> x >> y;
            farm[y][x] = 1;
        }

        // 탐색 시작
        int count = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                find(i, j, m, n);
                count += (cnt == 0 ? 0 : cnt /= cnt);
                // 0을 나누는 경우를 없애기 위한 삼중의문문
                cnt = 0;
            }
        }

        // 배추흰지렁이 출력 후 초기화
        // vis, farm 배열 모두 초기화 해주기
        cout << count << endl;
        count = 0;
        for(int i = 0; i < 50; i++){
            for(int j = 0; j < 50; j++){
                farm[i][j] = 0;
                vis[i][j] = 0;
            }
        }
    }
}