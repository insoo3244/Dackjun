// https://www.acmicpc.net/problem/2661
// 2026-02-12
#include <iostream>
#include <vector>
#include <string>

using namespace std;

/*
    전략 구상

    어차피 최솟값을 찾아야하니까 중간에 1이 꼭 끼어있어야 하고,
    반복되는 구조를 피해야 하니, 2와 3이 쭉 번갈아 가면서 나와야 함
    그러면 걍 홀수인덱스 = 2 OR 3 반복
    짝수인덱스는 무조건 1 고정아님?
    -> 1213121312131213을 무조건 반복하면 되는거 아닌가

    .. 같은 단순한 구조를 출력하는게 다 일거라고 생각했는데,
    다시 보니까, 1213이 반복되어버림

    백트레킹 관점으로 생각

    길이가 7인 수열을 만든다면,
    1
    12 : 1이 오면 나쁜 수열
    121 
    1213 : 2가 오면 나쁜 수열
    12131
    121312 : 1, 3이 오면 나쁜 수열
    1213121

    == 제미나이 도움 ==
    인접한 두 부분수열이 동일한지, 아닌지는 list를 계속 쌓으면서 검사해야 함
    n = 7 일 때,
    1 -> 중복 수열 없음
    11 -> 중복 수열 발견. 백 트레킹
    1 -> 중복 수열 없음
    12 -> 중복 수열 없음
    121 ...
    ...
    1213121 완성

    이런 식으로 매번 쌓을 때마다 검사하면 중복 수열은 절대 없음

    그래서 중복인지 아닌지는 어떻게 판단함?
    -> 최근에 list에 쌓은 요소가 중복을 일으키는지 판단해야 하므로, 배열의 끝 부분만 검사
    -> 배열의 끝 ~ list의 길이의 절반만큼 검사하기
    -> 방식 : 비교할 부분과 아닌 부분을 딱 잘라서 검사함
    ex) 1213 -> 12131 의 과정
        방금 막 배열의 끝에 1이 추가됨
        비교할 길이 1 : '1' 과 '3' 만 비교
        비교할 길이 2 : '31' 과 '21' 만 비교
        list의 길이의 절반만큼 검사하면 되므로, 비교는 여기서 끝
        중복검사를 통과했으니, 12131은 통과 -> 재귀 시작
    -> 여기서 쓴 함수 : string의 substr(탐색을 시작할 위치, 탐색할 개수)
    * 주의 : substr의 탐색할 개수에 0을 입력하면, 비교할 때 무조건 '참'이 나오니 
    개수가 무조건 1 이상 입력되게끔 반복문 설정 잘 하기

*/

char arr[3] = {'1', '2', '3'};

string list; // 수열

// 백 트레킹 인자 : 수열의 길이
void bT(int n){
    // 만약 list 길이가 0 이라면,
    if(list.length() == 0){
        list += '1'; // 1 부터 대입
    }
    else if(list.length() == n){ // 길이가 n에 도달했다면,
        cout << list; // 수열 출력
        exit(0); // 함수 완전 종료
    }

    for(auto x : arr){
        list += x; // 일단 숫자 이어붙이기

        // 중복 검사
        bool isOk = true;
        for(int i = 1; i < list.length() / 2 + 1; i++){
            // list의 마지막 부분부터 (최근 추가한 것 부터 검사)
            if(list.substr(list.length() - i, i) == list.substr(list.length() - 2 * i, i)){
                isOk = false;
                break;
            }
        }

        if(isOk){ // 중복이 없다면,
            bT(n); // 재귀
        }

        list.pop_back();
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    // 수열의 길이 n
    int n;
    cin >> n;

    // 숫자 조합
    bT(n);
}